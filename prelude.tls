;;Foreign functions

;;Print function is reexported, so we can later redefine it
;;for each different datatype
(print a = _print a)
(eq a b = _eq a b)

;;Booleans

;;Shorthands for the data constructors of the boolean datatypes
(true = Bool True)
(false = Bool False)
(print (Bool a) = a)

;;Define the if clause, using pattern matching 
;;(Only the relevant clause is evaluated, because the language is lazy)
(if (:literal true) a b = a)
(if (:literal false) a b = b)

;;We can define a little function we can use to test stuff 
(assertEqual a b = (if (eq a b) () (print (error a is-not-equal-to b))))

;;Check if the booleans work :) 
(assertEqual (if true foo bar) foo)
(assertEqual (if false foo bar) bar)

;;Some other boolean functions
(and (:literal true) (:literal true) = true)
(and (Bool a) (Bool a) = false)

(or (:literal false) (:literal false) = false)
(or (Bool a) (Bool a) = true)

(not (:literal false) = true)
(not (:literal true) = false)

;;Test those, using DeMorgan's laws (or the other way around)
(test-demorgan (Bool a) (Bool b) = (
  (one = not (and (Bool a) (Bool b)))
  (two = or (not (Bool a)) (not (Bool b)))
  (assertEqual one two)
))
(test-demorgan true false)
(test-demorgan true true)
(test-demorgan false true)
(test-demorgan false false)
;;
;;Pairs
;;

;; Define the pair datatype 
(cons a b = Pair a b)
(car (Pair a b) = a)
(cdr (Pair a b) = b)

(print (Pair a b) = print a . b)

;; Check if they work as well
(assertEqual (car (cons foo bar)) foo)
(assertEqual (cdr (cons foo bar)) bar)

;; Peano arithmetic

;; Define the Peano axioms
(0 = Nat Zero)
(+1 (Nat a) =  Nat (Succ a))

;; Shortcuts for some numbers
(1 = +1 0)
(2 = +1 1)
(3 = +1 2)
(4 = +1 3)

(assertEqual (+1 1) 2)
(assertEqual (+1 2) 3)

;; The plus function
(+ (:literal 0) (Nat a) = Nat a)
(+ (Nat (Succ a)) (Nat b) = (+1 (+ (Nat a) (Nat b))))

(assertEqual (+ 0 0) 0)
(assertEqual (+ 0 1) 1)
;; May be occasionally useful
(assertEqual (+ 1 1) 2)
(assertEqual (+ 2 2) 4)

;; Lambdas 

(map a (:lambda fun) = fun a)

;;Pass an existing function
(this-is a = (this is a))
(assertEqual (map foo this-is) (this is foo))
;;Pass an inline function (but be sure to give it a name)
(assertEqual (map bar (fun a = (this is a))) (this is bar))

;;Lists (WIP)

;; Define the list datatype
;;(list (:rest list) = list (:rest list))
;;(log list (:rest content) = content

;; Some helper functions

;;(head (list head (:rest tail)) a)
;;(head (list head (:rest tail)) (list tail))

;;(map (:lambda fun) (list head) = (list (fun head)) )
;;(map (:lambda fun) (list head (:rest tail)) = (list (fun head) (:rest (map fun tail))))
